import numpy as np
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import cross_val_score
from sklearn.neighbors import KNeighborsClassifier

# Load data
data = load_breast_cancer()
X = data.data
y = data.target
n_features = X.shape[1]

# Cuckoo Search Parameters
n_nests = 5
pa = 0.25  # probability of abandoning worse nests
n_iterations = 10
alpha = 0.9  # weight for accuracy vs feature count

# Fitness function: maximize accuracy and minimize number of features
def fitness(solution):
    if np.count_nonzero(solution) == 0:
        return 0  # avoid empty feature subset
    
    selected_features = [i for i in range(n_features) if solution[i] == 1]
    X_subset = X[:, selected_features]
    
    classifier = KNeighborsClassifier(n_neighbors=5)
    # Use 5-fold cross-validation accuracy as fitness
    scores = cross_val_score(classifier, X_subset, y, cv=5)
    accuracy = scores.mean()
    
    # Combine accuracy and simplicity (fewer features)
    feature_ratio = np.count_nonzero(solution) / n_features
    return alpha * accuracy + (1 - alpha) * (1 - feature_ratio)

# Initialize nests (binary vectors)
nests = np.random.randint(2, size=(n_nests, n_features))
fitness_values = np.array([fitness(nest) for nest in nests])

best_index = np.argmax(fitness_values)
best_nest = nests[best_index].copy()
best_fitness = fitness_values[best_index]

def levy_flight_binary(current_solution):
    # Perform a Levy flight step but keep solution binary by flipping bits randomly
    step_size = np.random.poisson(1, size=n_features)
    new_solution = current_solution.copy()
    flip_indices = np.where(step_size > 0)[0]
    for idx in flip_indices:
        new_solution[idx] = 1 - new_solution[idx]  # flip bit
    return new_solution

for iteration in range(n_iterations):
    for i in range(n_nests):
        new_solution = levy_flight_binary(nests[i])
        new_fitness = fitness(new_solution)
        if new_fitness > fitness_values[i]:
            nests[i] = new_solution
            fitness_values[i] = new_fitness
            if new_fitness > best_fitness:
                best_nest = new_solution.copy()
                best_fitness = new_fitness
    
    # Abandon some nests and create new ones randomly
    for i in range(n_nests):
        if np.random.rand() < pa:
            nests[i] = np.random.randint(2, size=n_features)
            fitness_values[i] = fitness(nests[i])
            if fitness_values[i] > best_fitness:
                best_nest = nests[i].copy()
                best_fitness = fitness_values[i]

    print(f"Iteration {iteration+1}: Best Fitness = {best_fitness:.4f}")

# Final results
selected_features = [i for i in range(n_features) if best_nest[i] == 1]
print("\nSelected feature indices:", selected_features)
print(f"Number of features selected: {len(selected_features)}")
import numpy as np
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import cross_val_score
from sklearn.neighbors import KNeighborsClassifier

# Load data
data = load_breast_cancer()
X = data.data
y = data.target
n_features = X.shape[1]

# Cuckoo Search Parameters
n_nests = 5
pa = 0.25  # probability of abandoning worse nests
n_iterations = 10
alpha = 0.9  # weight for accuracy vs feature count

# Fitness function: maximize accuracy and minimize number of features
def fitness(solution):
    if np.count_nonzero(solution) == 0:
        return 0  # avoid empty feature subset
    
    selected_features = [i for i in range(n_features) if solution[i] == 1]
    X_subset = X[:, selected_features]
    
    classifier = KNeighborsClassifier(n_neighbors=5)
    # Use 5-fold cross-validation accuracy as fitness
    scores = cross_val_score(classifier, X_subset, y, cv=5)
    accuracy = scores.mean()
    
    # Combine accuracy and simplicity (fewer features)
    feature_ratio = np.count_nonzero(solution) / n_features
    return alpha * accuracy + (1 - alpha) * (1 - feature_ratio)

# Initialize nests (binary vectors)
nests = np.random.randint(2, size=(n_nests, n_features))
fitness_values = np.array([fitness(nest) for nest in nests])

best_index = np.argmax(fitness_values)
best_nest = nests[best_index].copy()
best_fitness = fitness_values[best_index]

def levy_flight_binary(current_solution):
    # Perform a Levy flight step but keep solution binary by flipping bits randomly
    step_size = np.random.poisson(1, size=n_features)
    new_solution = current_solution.copy()
    flip_indices = np.where(step_size > 0)[0]
    for idx in flip_indices:
        new_solution[idx] = 1 - new_solution[idx]  # flip bit
    return new_solution

for iteration in range(n_iterations):
    for i in range(n_nests):
        new_solution = levy_flight_binary(nests[i])
        new_fitness = fitness(new_solution)
        if new_fitness > fitness_values[i]:
            nests[i] = new_solution
            fitness_values[i] = new_fitness
            if new_fitness > best_fitness:
                best_nest = new_solution.copy()
                best_fitness = new_fitness
    
    # Abandon some nests and create new ones randomly
    for i in range(n_nests):
        if np.random.rand() < pa:
            nests[i] = np.random.randint(2, size=n_features)
            fitness_values[i] = fitness(nests[i])
            if fitness_values[i] > best_fitness:
                best_nest = nests[i].copy()
                best_fitness = fitness_values[i]

    print(f"Iteration {iteration+1}: Best Fitness = {best_fitness:.4f}")

# Final results
selected_features = [i for i in range(n_features) if best_nest[i] == 1]
print("\nSelected feature indices:", selected_features)
print(f"Number of features selected: {len(selected_features)}")

OUTPUT:
Iteration 1: Best Fitness = 0.8934
Iteration 2: Best Fitness = 0.8953
Iteration 3: Best Fitness = 0.8953
Iteration 4: Best Fitness = 0.8953
Iteration 5: Best Fitness = 0.8953
Iteration 6: Best Fitness = 0.8953
Iteration 7: Best Fitness = 0.8953
Iteration 8: Best Fitness = 0.8953
Iteration 9: Best Fitness = 0.9145
Iteration 10: Best Fitness = 0.9145

Selected feature indices: [0, 1, 2, 4, 10, 17, 19, 22, 24, 25]
Number of features selected: 10
